# 数字电路实验 Lab 8 实验报告

<center>奚项正 PB23000020</center>

[TOC]



## 第一部分：基础的串口通信

### 1. 串口回显

#### Test 模块

```v
module Test(
    input                   [ 0 : 0]            uart_din,
    output                  [ 0 : 0]            uart_dout
);
assign uart_dout = uart_din;
endmodule
```

#### 上板测试

串口处输入`Test`并点击`input`，再输入空格加`Uart`并点击`input`

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\Test_impl.png)



### 2. 串口发送

#### Top 模块

```v
module Top(
    input                   [ 0 : 0]        clk,
    input                   [ 0 : 0]        btn,

    input                   [ 7 : 0]        sw,

    output                  [ 3 : 0]        seg_data,
    output                  [ 2 : 0]        seg_an,

    output                  [ 0 : 0]        uart_dout
);

wire [ 0 : 0]   rst;
wire [ 7 : 0]   dout_data;
wire [ 0 : 0]   dout_vld;
reg  [31 : 0]   output_data;

reg sig_r1, sig_r2;
always @(posedge clk) begin
    if (rst) begin
        sig_r1 <= 0;
        sig_r2 <= 0;
    end
    else begin
        sig_r1 <= btn;			//一级上升沿检测寄存器
        sig_r2 <= sig_r1;		//二级上升沿检测寄存器
    end
end
assign dout_vld = (sig_r1 && ~sig_r2) ? 1 : 0;	//对 btn 信号进行取上升沿，防止接收相同字符的输出请求多次

Send send (
    .clk            (clk), 
    .rst            (rst),
    .dout           (uart_dout),
    .dout_vld       (dout_vld),
    .dout_data      (dout_data)
);

Segment segment (
    .clk            (clk),
    .rst            (rst),
    .output_data    (output_data),
    .output_valid   (8'H03),
    .seg_data       (seg_data),
    .seg_an         (seg_an)
);

always @(posedge clk) begin
    if (rst)
        output_data <= 0;
    else
        output_data <= {25'B0, sw[6:0]};
end

assign rst = sw[7];
assign dout_data = output_data[7:0];
endmodule
```

#### Send 模块

```v
module Send(
    input                   [ 0 : 0]        clk, 
    input                   [ 0 : 0]        rst,

    output      reg         [ 0 : 0]        dout,

    input                   [ 0 : 0]        dout_vld,
    input                   [ 7 : 0]        dout_data
);

// Counter and parameters
localparam FullT        = 10416;
localparam TOTAL_BITS   = 9;
reg [13 : 0] div_cnt;           // 分频计数器，范围 0 ~ 10416
reg [ 4 : 0] dout_cnt;          // 位计数器，范围 0 ~ 9

// Main FSM
localparam WAIT     = 0;
localparam SEND     = 1;
reg current_state, next_state;
always @(posedge clk) begin
    if (rst)
        current_state <= WAIT;
    else
        current_state <= next_state;
end

always @(*) begin
    next_state = current_state;
    case (current_state)
        // TODO
        WAIT:   begin
            if (dout_vld == 1) begin	// vld 为 1 时开始发送
                next_state = SEND;
            end
        end
        SEND:   begin
            if (dout_cnt == TOTAL_BITS && div_cnt == FullT) begin	// 发送完所有 bits 的该周期结束时，重回 WAIT 态
                next_state = WAIT;
            end
        end
    endcase

end

// Counter
always @(posedge clk) begin
    if (rst)
        div_cnt <= 13'H0;
    else if (current_state == SEND) begin
        // TODO
        if (div_cnt > FullT)	// 计数器，每 FullT 循环一次
            div_cnt <= 13'H0;
        else
            div_cnt <= div_cnt + 13'H1;
    end
    else
        div_cnt <= 13'H0;
end

always @(posedge clk) begin
    if (rst)
        dout_cnt <= 4'H0;
    else if (current_state == SEND) begin
        // TODO
        if (dout_cnt > TOTAL_BITS)
            dout_cnt <= 10'H0;
        else begin
            if (div_cnt == FullT)	// div_cnt 每循环一次，dout_cnt 增加 1，进入下一位发送
                dout_cnt <= dout_cnt + 10'H1;	
            else
                dout_cnt <= dout_cnt;
        end
    end
    else
        dout_cnt <= 4'H0;
end

reg [7 : 0] temp_data;      // 用于保留待发送数据，这样就不怕 dout_data 的变化了
always @(posedge clk) begin
    if (rst)
        temp_data <= 8'H0;
    else if (current_state == WAIT && dout_vld)
        temp_data <= dout_data;
end

always @(posedge clk) begin
    if (rst)
        dout <= 1'B1;
    else begin
        // TODO
        if (next_state == WAIT) begin
            dout <= 1'B1;
        end
        else begin
            case (dout_cnt)
                0:  dout <= 1'B0;		// 标记起始位
                9:  dout <= 1'B1;		// 标记停止位
                default:    dout <= temp_data[dout_cnt-1];	//数据位，从低位至高位依次发送
            endcase
        end
    end
end
endmodule
```

#### Segment 模块

```v
module Segment(
    input                       clk,
    input                       rst,
    input       [31:0]          output_data,
    input       [ 7:0]          output_valid,
    output reg  [ 3:0]          seg_data,
    output reg  [ 2:0]          seg_an
);

reg [31:0]  counter;
reg [2:0]   seg_id;

always @(posedge clk) begin
    if (rst) begin
        counter <= 0;
    end
    else if (counter >= 250000) begin
        counter <= 0;
    end
    else begin
        counter <= counter + 1;
    end
end

always @(posedge clk) begin
    if (rst) begin
        seg_id <= 0;
    end
    else if (counter == 1) begin
        if (seg_id >= 8) begin
            seg_id <= 0;
        end
        else begin
            seg_id <= seg_id + 1;
        end
    end
    else begin
        seg_id <= seg_id;
    end
end

always @(*) begin
    seg_data = 0;
    if (output_valid[seg_id] == 1) begin
        seg_an = seg_id;
    end
    else begin
        seg_an = 0;
    end

    case (seg_an)
        0: seg_data = output_data[3:0];
        1: seg_data = output_data[7:4];
        2: seg_data = output_data[11:8];
        3: seg_data = output_data[15:12];
        4: seg_data = output_data[19:16];
        5: seg_data = output_data[23:20];
        6: seg_data = output_data[27:24];
        7: seg_data = output_data[31:28];
        default: seg_data = 0;
    endcase
end
endmodule
```

#### 仿真测试

```v
module Send_tb();
reg clk;
reg btn;
reg [7:0] sw;
wire [3:0] seg_data;
wire [2:0] seg_an;
wire uart_dout;

initial begin
    clk = 0;
    sw = 8'b10000000;
    btn = 1;
    #10 btn = 0;
    sw = 8'h30;
    btn = 1;
    #10 btn = 0;

    #50000 sw = 8'h36;
    #50000 btn = 1;
    #10 btn = 0;
end

always #5 clk = ~clk;

Top top(
    .clk(clk),
    .btn(btn),
    .sw(sw),
    .seg_data(seg_data),
    .seg_an(seg_an),
    .uart_dout(uart_dout)
);
endmodule
```

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\Send_sim.png)

#### 上板测试

先令`sw = 00110000`并按下`btn`，再令`sw = 00110110`并按下`btn`

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\Send_impl.png)

### 3. 串口接收

#### Top 模块

```v
module Top(
    input                   [ 0 : 0]        clk,
    input                   [ 0 : 0]        rst,

    output                  [ 3 : 0]        seg_data,
    output                  [ 2 : 0]        seg_an,

    input                   [ 0 : 0]        uart_din
);

wire [ 7 : 0]   din_data;
wire [ 0 : 0]   din_vld;
reg  [31 : 0]   output_data;

Receive receive (
    .clk        (clk),
    .rst        (rst),
    .din        (uart_din),
    .din_vld    (din_vld),
    .din_data   (din_data)
);

Segment segment (
    .clk            (clk),
    .rst            (rst),
    .output_data    (output_data),
    .output_valid   (8'HFF),
    .seg_data       (seg_data),
    .seg_an         (seg_an)
);

always @(posedge clk) begin
    if (rst)
        output_data <= 32'B0;
    else if (din_vld)
        output_data <= {output_data[23:0], din_data};
end
endmodule
```

#### Receive 模块

```v
module Receive(
    input                   [ 0 : 0]        clk,
    input                   [ 0 : 0]        rst,

    input                   [ 0 : 0]        din,

    output      reg         [ 0 : 0]        din_vld,
    output      reg         [ 7 : 0]        din_data
);

// Counter and parameters
localparam FullT        = 10416;
localparam HalfT        = 5208;
localparam TOTAL_BITS   = 8;
reg [13 : 0] div_cnt;       // 分频计数器，范围 0 ~ 10416
reg [ 3 : 0] din_cnt;       // 位计数器，范围 0 ~ 8

// Main FSM
localparam WAIT     = 0;
localparam START    = 1;	// 接收起始状态，该状态只持续 HalfT
localparam RECEIVE  = 2;	// 接收数据状态，每位数据持续 FullT
reg [1:0] current_state, next_state;
reg next_div_cnt_flag;		// div_cnt 归零标记
always @(posedge clk) begin
    if (rst)
        current_state <= WAIT;
    else
        current_state <= next_state;
end

always @(*) begin
    next_state = current_state;
    next_div_cnt_flag = 0;
    case (current_state)
        // TODO
        WAIT:    begin
            if (din == 0) begin			// 起始位为 0
                next_state = START;
            end
        end
        START:   begin
            if (div_cnt == HalfT) begin		// START 态持续 HalfT，结束后进入 RECEIVE 态，并将 div_cnt 归零
                next_state = RECEIVE;
                next_div_cnt_flag = 1;
            end
        end
        RECEIVE: begin
            if (din_cnt == TOTAL_BITS && div_cnt == FullT) begin	// 所有数据位接收结束后回至 WAIT 态
                next_state = WAIT;
                next_div_cnt_flag = 1;
            end
            else if (div_cnt == FullT) begin	// 每位接收持续 FullT，每位结束后需将 div_cnt 归零
                next_div_cnt_flag = 1;
            end
        end
    endcase
end

// Counter
always @(posedge clk) begin
    if (rst)
        div_cnt <= 0;
    else if (current_state == START) begin
        // TODO
        if (next_div_cnt_flag)
            div_cnt <= 0;
        else
            div_cnt <= div_cnt + 1;
    end
    else if (current_state == RECEIVE) begin
        // TODO
        if (next_div_cnt_flag)
            div_cnt <= 0;
        else
            div_cnt <= div_cnt + 1;
    end
    else 
        div_cnt <= 0;
end

always @(posedge clk) begin
    if (rst)
        din_cnt <= 0;
    else if (current_state == RECEIVE) begin
        // TODO
        if (din_cnt == TOTAL_BITS && div_cnt == FullT) begin
            din_cnt <= 0;
        end
        else if (div_cnt == FullT) 		// 每位接收持续 FullT，每位结束后 din_cnt 增加 1
            din_cnt <= din_cnt + 1;
        else
            din_cnt <= din_cnt;
    end
    else
        din_cnt <= 0;
end


// Output signals
reg [ 0 : 0] accept_din;    // 位采样信号
always @(*) begin
    accept_din = 1'B0;
    // TODO
    if (div_cnt == FullT && din_cnt < TOTAL_BITS)		// 该位的中间时刻为最佳采样时刻
        accept_din = 1'B1;
end

always @(*) begin
    din_vld = 1'B0;
    // TODO
    if (div_cnt == FullT && din_cnt == TOTAL_BITS)		// 完成本轮接收
        din_vld = 1'B1;
end

always @(posedge clk) begin
    if (rst)
        din_data <= 8'B0;
    else if (current_state == WAIT)
        din_data <= 8'B0;
    else if (current_state == START)
        din_data <= 8'B0;
    else if (accept_din)
        din_data <= din_data | (din << din_cnt);
    else
        din_data <= din_data;
end
endmodule
```

#### Segment 模块

```v
module Segment(
    input                       clk,
    input                       rst,
    input       [31:0]          output_data,
    input       [ 7:0]          output_valid,
    output reg  [ 3:0]          seg_data,
    output reg  [ 2:0]          seg_an
);

reg [31:0]  counter;
reg [2:0]   seg_id;

always @(posedge clk) begin
    if (rst) begin
        counter <= 0;
    end
    else if (counter >= 250000) begin
        counter <= 0;
    end
    else begin
        counter <= counter + 1;
    end
end

always @(posedge clk) begin
    if (rst) begin
        seg_id <= 0;
    end
    else if (counter == 1) begin
        if (seg_id >= 8) begin
            seg_id <= 0;
        end
        else begin
            seg_id <= seg_id + 1;
        end
    end
    else begin
        seg_id <= seg_id;
    end
end

always @(*) begin
    seg_data = 0;
    if (output_valid[seg_id] == 1) begin
        seg_an = seg_id;
    end
    else begin
        seg_an = 0;
    end

    case (seg_an)
        0: seg_data = output_data[3:0];
        1: seg_data = output_data[7:4];
        2: seg_data = output_data[11:8];
        3: seg_data = output_data[15:12];
        4: seg_data = output_data[19:16];
        5: seg_data = output_data[23:20];
        6: seg_data = output_data[27:24];
        7: seg_data = output_data[31:28];
        default: seg_data = 0;
    endcase
end
endmodule
```

#### 仿真测试

```v
module Receive_tb();
reg clk;
reg rst;
wire [3:0] seg_data;
wire [2:0] seg_an;
reg uart_din;

initial begin
    clk = 0;
    rst = 1;
    uart_din = 1;
    #10 rst = 0;
    #1000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;

    #200000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
end

always #5 clk = ~clk;

Top top(
    .clk(clk),
    .rst(rst),
    .seg_data(seg_data),
    .seg_an(seg_an),
    .uart_din(uart_din)
);
endmodule
```

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\Receive_sim.png)

#### 上板测试

串口处输入`1234`并点击`input`

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\Receive_impl.png)

## 第二部分：LC3 处理器

### 1. 实验介绍

#### Basic 版本

请根据 ICS 教材以及所学知识，设计并搭建支持如下指令的 LC-3 处理器：

```v
parameter INST_ADD  = 4'b0001;
parameter INST_AND  = 4'b0101;
parameter INST_BR   = 4'b0000;
parameter INST_JMP  = 4'b1100;
parameter INST_JSR  = 4'b0100;
parameter INST_LD   = 4'b0010;
parameter INST_LDR  = 4'b0110;
parameter INST_LEA  = 4'b1110;
parameter INST_NOT  = 4'b1001;
parameter INST_ST   = 4'b0011;
parameter INST_STR  = 4'b0111;
```

你需要支持以上指令的功能执行。关于中断与异常处理、轮询等操作均不要求实现。

在开发板上，你的处理器需要支持如下的外设操作：

- 开关复位：`sw[7]` 为系统 `rst` 信号。为高电平时，系统内所有寄存器均复位到 0。

- 按钮控制：按下按钮后，处理器从 IF 状态开始执行一条指令的完整流程，最后回到 IF 状态。你需要对按钮信号进行取上升沿的处理操作。

- 数码管显示：数码管的高四位通过`sw[3:0]`显示对应寄存器中的数值。映射关系为：

  ```v
  sw[3:0]             output_data[31:16]
  0000                R0
  0001                R1
  0010                R2
  0011                R3
  0100                R4
  0101                R5
  0110                R6
  0111                R7
  1000                PC
  1001                IR
  1010                条件码寄存器
  ```

你需要完成的内容包括：

- 使用存储器 IP 核作为内存，并将 LC3-Tools 生成的机器码作为 COE 文件导入存储器。开始运行后，你的通路应当可以在不受外界干预的情况下正确执行存储器中的指令。
- 设计基于开关和数码管的数码管显示功能。
- 一段可以验证自己设计正确性的示例程序。由于我们目前无法在开发板上访问内存，因此请将最终的结果保存在寄存器中。

#### UART 版本

请根据文档中的内容，在 Basic 版本的基础上支持基于串口的命令控制。你需要实现的内容包括：

- 串口命令控制。为此你需要增加对于串口命令的解析单元，并正确连接到存储器、控制器等单元；
- 让七段数码管的低四位显示 `r` 指令读取的结果；
- 一段可以验证自己设计正确性的示例程序，并使用串口命令进行写入、运行、读取的操作。

### 2. 逻辑设计

$$
\text{Top 模块} 
\begin{cases}
\text{Controller 模块} 
\begin{cases}
\text{ALU 模块} \\
\text{RegFile 模块} \\
\text{存储器 IP 核} 
\end{cases}\\
\text{Segment 模块} \\
\text{Receive 模块} \\
\text{Send 模块} 
\end{cases}
$$

其中ALU 模块、Receive 模块、RegFile 模块、Segment 模块、Send 模块均属于对此前实验成果的例化使用，不再赘述。下面将重点介绍 Top 模块与 Controller 模块的逻辑设计。

我们首先指出，根据实验文档，作出了以下若干简化：

- 寻址空间为 $2^{10}$，即总存储空间为 $2^{10}\times 16$ bits，但所有地址仍按 16 位存储及进行运算，惟在操作内存时对地址视为截取其后 10 位；
- `LDI`、`RTI`、`STI`三条指令不予实现，`TRAP`指令仅用于实现停机；
- 关于中断与异常处理、轮询等操作均不予实现，并认为所有输入必定合法，凡非法输入将被直接忽视或被解释为某种合法输入。

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_fig1.png)

对于 Controller 模块，其由一个具有约 40 个状态的有限状态机作为主体，发出`LD_?`、`Gate?`等控制信号操纵数据通路，并用`?_sel`、`?MUX_sel`等控制信号选择数据源或多路复用器。待机状态 IDLE 下时若 `btn` 被按下，遂进入取指令及译码阶段，并根据指令前往各分支状态执行，包括地址计算、取操作数、执行、存储等；若`vld`取为 1，表明有外设操作需要执行，并通过`?_flag`进行对相应状态量的修改赋值。

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_fig2.png)

Top 模块中与 FGPA 平台的各端口连接的输入输出含义如下：

- 时钟`clk`提供时钟周期信号；
- 按钮`btn`用于执行单条指令，取其上升沿；
- 开关`sw`的最高位为系统复位信号，其低四位标记数码管的高四位所要求显示值的寄存器；
- 串口输入`uart_din`包含 Receive 模块可识别的串口操作数据帧；
- 灯`LED`指示按钮被按下的情况；
- 数码管`seg_data`与`seg_an`以分时复用方式轮流点亮每个数码管，其低四位读出串口操作所要求的内存地址的值；
- 串口输出`uart_dout `指示串口操作的执行情况。

串口操作共有 4 个，分别用`j,r,s,w`标识开头，其格式如下所示，其中 XXXX 表示一个 16 位数据的十六进制表示：

- `jXXXX`(JUMP)，跳转至 XXXX 地址处，即修改 PC 为 XXXX；
- `rXXXX`(READ)，读出内存 XXXX 地址处的值，在数码管低四位显示；
- `s`(START)，运行，即从当前 PC 开始依次执行指令，直到停机；
- `wXXXX`(WRITE)，写入 XXXX 数据至当前 PC 所对应的内存地址，并进行 PC 加 1。

### 3. 代码解释

#### ALU 模块

```v
module ALU(
    input                   [15 : 0]        src0,       // 数据源 0    
    input                   [15 : 0]        src1,       // 数据源 1  
    input                   [ 3 : 0]        sel,        // 运算选择
    output                  [15 : 0]        res         // 运算结果
);

wire [15:0] add_out;        // ADD 运算，对应 sel = 4'b0001
wire [15:0] and_out;        // AND 运算，对应 sel = 4'b0010
wire [15:0] not_out;        // NOT 运算，对应 sel = 4'b0100
wire [15:0] src1_out;       // src 直出，对应 sel = 4'b1000

assign add_out = src0 + src1;
assign and_out = src0 & src1;
assign not_out = ~src0;
assign src1_out = src1;

assign res = ({16{sel[0]}} & add_out) |
             ({16{sel[1]}} & and_out) |
             ({16{sel[2]}} & not_out) |
             ({16{sel[3]}} & src1_out);

endmodule
```

#### Controller 模块

```v
module Controller(
    input                       clk,            // 时钟信号
    input                       rst,            // 系统复位信号
    input                       btn,            // 按下按钮后，处理器从 IF 状态开始执行一条指令的完整流程
    input       [ 3:0]          sw,             // 控制寄存器编号的开关
    input                       vld,            /* 串口输入的有效信号 */
    input       [ 1:0]          mode,           /* 串口输入的指令类型 */
    input       [15:0]          addr,           /* 串口输入的指令参数 */
    output reg  [15:0]          echo,           // 数码管的高四位显示对应寄存器中的数值
    output      [15:0]          res             /* 数码管的低四位显示串口读出操作的结果 */
);

parameter IDLE      = 8'b1101_0000;             // 待机状态
parameter FETCH_0   = 8'b1101_0001;             // 取指令阶段
parameter FETCH_1   = 8'b1101_0010;
parameter FETCH_2   = 8'b1101_0011;
parameter FETCH_3   = 8'b1101_0100;
parameter DECODE    = 8'b1101_0101;             // 译码阶段

parameter ADD_0     = 8'b0001_0000;             // 各 LC-3 指令的地址计算、取操作数、执行、存储阶段
parameter ADD_1     = 8'b0001_0001;

parameter AND_0     = 8'b0101_0000;
parameter AND_1     = 8'b0101_0001;

parameter BR_0      = 8'b0000_0000;
parameter BR_1      = 8'b0000_0001;

parameter JMP_0     = 8'b1100_0000;
parameter JMP_1     = 8'b1100_0001;

parameter JSR_0     = 8'b0100_0000;
parameter JSR_1     = 8'b0100_0001;
parameter JSR_2     = 8'b0100_0010;

parameter LD_0      = 8'b0010_0000;
parameter LD_1      = 8'b0010_0001;
parameter LD_2      = 8'b0010_0010;
parameter LD_3      = 8'b0010_0011;

parameter LDR_0     = 8'b0110_0000;
parameter LDR_1     = 8'b0110_0001;
parameter LDR_2     = 8'b0110_0010;
parameter LDR_3     = 8'b0110_0011;

parameter LEA_0     = 8'b1110_0000;
parameter LEA_1     = 8'b1110_0001;

parameter NOT_0     = 8'b1001_0000;
parameter NOT_1     = 8'b1001_0001;

parameter ST_0      = 8'b0011_0000;
parameter ST_1      = 8'b0011_0001;
parameter ST_2      = 8'b0011_0010;
parameter ST_3      = 8'b0011_0011;

parameter STR_0     = 8'b0111_0000;
parameter STR_1     = 8'b0111_0001;
parameter STR_2     = 8'b0111_0010;
parameter STR_3     = 8'b0111_0011;

parameter TRAP      = 8'b1111_0000;             // 仅支持 TRAP x25，用于串口运行操作的停机，需要 rst 方可恢复
parameter JUMP      = 8'b1111_0001;  
parameter START     = 8'b1111_0010; 
parameter WRITE_0   = 8'b1111_0011;
parameter WRITE_1   = 8'b1111_0100;

wire [15:0] DataPath;

reg  [ 2:0] DR_sel; 
reg  [ 2:0] SR1_sel; 
reg  [ 2:0] SR2_sel; 
reg  [ 3:0] ALU_sel; 
reg         MEM_sel;

wire [15:0] SR1_out;
wire [15:0] SR2_out;
wire [15:0] ALU_out;
wire [15:0] MEM_out;

reg         SR2MUX_sel;
reg         ADDR1MUX_sel;
reg  [ 1:0] ADDR2MUX_sel;
reg  [ 1:0] PCMUX_sel;
reg         MARMUX_sel;
reg         MDRMUX_sel;

reg  [15:0] SR2MUX_out;
reg  [15:0] ADDR1MUX_out;
reg  [15:0] ADDR2MUX_out;
reg  [15:0] PCMUX_out;
reg  [15:0] MARMUX_out;
reg  [15:0] MDRMUX_out;

reg         LD_MDR;
reg         LD_MAR;
reg         LD_IR;
reg         LD_CC;
reg         LD_REG;
reg         LD_PC;

reg         GateMDR; 
reg         GateALU;
reg         GatePC;
reg         GateMARMUX;

reg  [15:0] IR; 
reg  [ 2:0] CC; 
reg  [15:0] PC;
reg  [15:0] MDR;
reg  [15:0] MAR;

wire [15:0] echo_out;
reg  [15:0] addr_temp;
reg         jump_flag;
reg         start_flag;
reg         write_flag;

reg  [15:0] cnt;

reg  [ 7:0] current_state;
reg  [ 7:0] next_state;

assign DataPath = ({16{GateMDR}} & MDR) | ({16{GateALU}} & ALU_out) | ({16{GatePC}} & PC) | ({16{GateMARMUX}} & MARMUX_out);

always @(*) begin
    case (sw)
        4'b1000: echo = PC;
        4'b1001: echo = IR;
        4'b1010: echo = CC;
        4'b1011: echo = MAR;
        4'b1100: echo = MDR;
        4'b1101: echo = current_state;
        4'b1110: echo = current_state;
        4'b1111: echo = current_state; 
        default: echo = echo_out;       /* sw[3] == 0 时回显各寄存器的值 */
    endcase
end

// Part 1: 使用同步时序进行状态更新，即更新 current_state 的内容
always @(posedge clk) begin
    if (rst)  
        current_state <= IDLE;
    else 
        current_state <= next_state;
end

always @(posedge clk) begin
    if (rst)  
        cnt <= 0;
    else if (start_flag)
        cnt <= addr;
    else if (current_state == IDLE && cnt > 0)      /* 指令条数倒计数，用于串口运行操作 */
        cnt <= cnt - 1;
    else
        cnt <= cnt;
end

// Part 2: 使用组合逻辑判断状态跳转逻辑，即根据 current_state 与其他信号确定 next_state
always @(*) begin
    next_state = current_state;
    case (current_state)
        IDLE: begin
            if (vld) begin
                case (mode)
                    2'b00: begin            /* 串口跳转 jump 操作 */
                        jump_flag = 1;      /* 直接修改 PC */
                        next_state = JUMP;
                    end
                    2'b01: begin            /* 串口读出 read 操作*/
                        addr_temp = addr;   /* 将此时的地址保存至 temp */
                        next_state = IDLE;
                    end
                    2'b10: begin            /* 串口运行 start 操作*/
                        start_flag = 1;     /* 连续执行指令并进行倒计数，遇到 TRAP x25 或达到最大指令条数时停止 */
                        next_state = START;
                    end
                    2'b11: begin            /* 串口写入 write 操作*/
                        write_flag = 1;     /* 直接修改 MAR, MDR 以修改内存 */   
                        next_state = WRITE_0;
                    end      
                endcase
            end
            else if (cnt > 0) begin
                next_state = FETCH_0;
            end
            else if (btn) begin
                next_state = FETCH_0;
            end
        end
        FETCH_0: begin
            GatePC = 1;
            LD_MAR = 1;
            next_state = FETCH_1;
        end
        FETCH_1: begin
            LD_MAR = 0;
            GatePC = 0;
            MDRMUX_sel = 0;
            LD_MDR = 1;
            next_state = FETCH_2;
        end
        FETCH_2: begin
            LD_MDR = 0;
            GateMDR = 1;
            LD_IR = 1;
            next_state = FETCH_3;
        end
        FETCH_3: begin
            GateMDR = 0;
            LD_IR = 0;
            PCMUX_sel = 0;
            LD_PC = 1;
            next_state = DECODE;
        end
        DECODE: begin
            LD_PC = 0;
            case (IR[15:12])
                4'b0001: next_state = ADD_0;
                4'b0101: next_state = AND_0;
                4'b0000: next_state = BR_0;
                4'b1100: next_state = JMP_0;
                4'b0100: next_state = JSR_0;
                4'b0010: next_state = LD_0;
                4'b0110: next_state = LDR_0;
                4'b1110: next_state = LEA_0;
                4'b1001: next_state = NOT_0;
                4'b0011: next_state = ST_0;
                4'b0111: next_state = STR_0;
                4'b1111: next_state = TRAP;
                default: next_state = IDLE;
            endcase
        end

        ADD_0: begin
            SR1_sel = IR[8:6];
            SR2_sel = IR[2:0];   

            SR2MUX_sel = (IR[5] == 0) ? 0 : 1;
            ALU_sel = 4'b0001;
            GateALU = 1;

            DR_sel = IR[11:9];
            LD_REG = 1;
            LD_CC = 1;
            next_state = ADD_1;
        end
        ADD_1: begin
            GateALU = 0;
            LD_REG = 0;
            LD_CC = 0;
            next_state = IDLE;
        end

        AND_0: begin
            SR1_sel = IR[8:6];
            SR2_sel = IR[2:0];
  
            SR2MUX_sel = (IR[5] == 0) ? 0 : 1;
            ALU_sel = 4'b0010;
            GateALU = 1;

            DR_sel = IR[11:9];
            LD_REG = 1;
            LD_CC = 1;
            next_state = AND_1;
        end
        AND_1: begin
            GateALU = 0;
            LD_REG = 0;
            LD_CC = 0;
            next_state = IDLE;
        end

        BR_0: begin
            if (CC[2] & IR[11] == 1 | CC[1] & IR[10] == 1 | CC[0] & IR[9] == 1) begin
                ADDR1MUX_sel = 0;
                ADDR2MUX_sel = 2;
                PCMUX_sel = 1;
                LD_PC = 1;
                next_state = BR_1;
            end
            else begin
                next_state = IDLE;
            end
        end
        BR_1: begin    
            LD_PC = 0;
            next_state = IDLE;
        end

        JMP_0: begin
            SR1_sel = IR[8:6];

            ADDR1MUX_sel = 1;
            ADDR2MUX_sel = 0;
            PCMUX_sel = 1;
            LD_PC = 1;
            next_state = JMP_1;
        end
        JMP_1: begin    
            LD_PC = 0;
            next_state = IDLE;
        end

        JSR_0: begin
            GatePC = 1;
            DR_sel = 7;
            LD_REG = 1;
            next_state = JSR_1;
        end
        JSR_1: begin
            LD_REG = 0;
            GatePC = 0;
            if (IR[11] == 0) begin
                SR1_sel = IR[8:6];
                ADDR1MUX_sel = 1;
                ADDR2MUX_sel = 0;
            end
            else begin
                ADDR1MUX_sel = 0;
                ADDR2MUX_sel = 3;
            end
            PCMUX_sel = 1;
            LD_PC = 1;
            next_state = JSR_2;
        end
        JSR_2: begin    
            LD_PC = 0;
            next_state = IDLE;
        end

        LD_0: begin
            ADDR1MUX_sel = 0;
            ADDR2MUX_sel = 2;
            MARMUX_sel = 1;
            GateMARMUX = 1;
            LD_MAR = 1;
            next_state = LD_1;
        end
        LD_1: begin
            LD_MAR = 0;
            GateMARMUX = 0;
            MDRMUX_sel = 0;
            LD_MDR = 1;
            LD_CC = 1;
            next_state = LD_2;
        end
        LD_2: begin
            LD_MDR = 0;
            GateMDR = 1;
            DR_sel = IR[11:9];
            LD_REG = 1;
            next_state = LD_3;
        end
        LD_3: begin
            LD_REG = 0;
            LD_CC = 0;
            GateMDR = 0;
            next_state = IDLE;
        end

        LDR_0: begin
            SR1_sel = IR[8:6];

            ADDR1MUX_sel = 1;
            ADDR2MUX_sel = 1;
            MARMUX_sel = 1;
            GateMARMUX = 1;
            LD_MAR = 1;
            next_state = LDR_1;
        end
        LDR_1: begin
            LD_MAR = 0;
            GateMARMUX = 0;
            MDRMUX_sel = 0;
            LD_MDR = 1;
            LD_CC = 1;
            next_state = LDR_2;
        end
        LDR_2: begin
            LD_MDR = 0;
            GateMDR = 1;
            DR_sel = IR[11:9];
            LD_REG = 1;
            next_state = LDR_3;
        end
        LDR_3: begin
            LD_REG = 0;
            LD_CC = 0;
            GateMDR = 0;
            next_state = IDLE;
        end

        LEA_0: begin
            ADDR1MUX_sel = 0;
            ADDR2MUX_sel = 2;
            MARMUX_sel = 1;
            GateMARMUX = 1;
            DR_sel = IR[11:9];
            LD_REG = 1;
            LD_CC = 1;
            next_state = LEA_1;
        end
        LEA_1: begin
            LD_REG = 0;
            LD_CC = 0;
            GateMARMUX = 0;
            next_state = IDLE;
        end

        NOT_0: begin
            SR1_sel = IR[8:6];
   
            SR2MUX_sel = 0;
            ALU_sel = 4'b0100;
            GateALU = 1;

            DR_sel = IR[11:9];
            LD_REG = 1;
            LD_CC = 1;
            next_state = NOT_1;
        end
        NOT_1: begin
            GateALU = 0;
            LD_REG = 0;
            LD_CC = 0;
            next_state = IDLE;
        end

        ST_0: begin
            ADDR1MUX_sel = 0;
            ADDR2MUX_sel = 2;
            MARMUX_sel = 1;
            GateMARMUX = 1;
            LD_MAR = 1;
            next_state = ST_1;
        end
        ST_1: begin
            LD_MAR = 0;
            GateMARMUX = 0;
            SR1_sel = IR[11:9];

            ADDR1MUX_sel = 1;
            ADDR2MUX_sel = 0;
            MARMUX_sel = 1;
            GateMARMUX = 1;
            MDRMUX_sel = 1;
            LD_MDR = 1;
            next_state = ST_2;
        end
        ST_2: begin
            LD_MDR = 0;
            GateMARMUX = 0;
            MEM_sel = 1;
            next_state = ST_3;
        end
        ST_3: begin
            MEM_sel = 0;
            next_state = IDLE;
        end

        STR_0: begin
            SR1_sel = IR[8:6];
            ADDR1MUX_sel = 1;
            ADDR2MUX_sel = 1;
            MARMUX_sel = 1;
            GateMARMUX = 1;
            LD_MAR = 1;
            next_state = STR_1;
        end
        STR_1: begin
            LD_MAR = 0;
            GateMARMUX = 0;
            SR1_sel = IR[11:9];

            ADDR1MUX_sel = 1;
            ADDR2MUX_sel = 0;
            MARMUX_sel = 1;
            GateMARMUX = 1;
            MDRMUX_sel = 1;
            LD_MDR = 1;
            next_state = STR_2;
        end
        STR_2: begin
            LD_MDR = 0;
            GateMARMUX = 0;
            MEM_sel = 1;
            next_state = STR_3;
        end
        STR_3: begin
            MEM_sel = 0;
            next_state = IDLE;
        end

        TRAP: begin
            next_state = TRAP;
        end
		JUMP: begin
            jump_flag = 0;
            next_state = IDLE;
        end
        START: begin
            start_flag = 0;
            next_state = IDLE;
        end
        WRITE_0: begin
            write_flag = 0; 
            MEM_sel = 1;
            next_state = WRITE_1;
        end
		WRITE_1: begin
            MEM_sel = 0;
            next_state = IDLE;
        end
    endcase
end

always @(posedge clk) begin 
    if (rst)                MAR <= 0;
    else if (write_flag)    MAR <= PC;
    else if (LD_MAR)        MAR <= DataPath;
    else                    MAR <= MAR;
end

always @(posedge clk) begin 
    if (rst)                MDR <= 0;
    else if (write_flag)    MDR <= addr;
    else if (LD_MDR)        MDR <= MDRMUX_out;
    else                    MDR <= MDR;
end

always @(posedge clk) begin
    if (rst)                IR <= 0;
    else if (LD_IR)         IR <= DataPath;
    else                    IR <= IR;
end

always @(posedge clk) begin
    if (rst)                CC <= 0;
    else if (LD_CC) begin
        CC[2] <= (DataPath[15] == 1) ? 1 : 0;
        CC[1] <= (DataPath == 0) ? 1 : 0;
        CC[0] <= (DataPath[15] == 0 && DataPath != 0) ? 1 : 0;
    end
    else                    CC <= CC;
end

always @(posedge clk) begin
    if (rst)                PC <= 0;
    else if (jump_flag)     PC <= addr;
	else if (write_flag)    PC <= PC + 1;
    else if (LD_PC)         PC <= PCMUX_out;
    else                    PC <= PC;
end

always @(*) begin
    case (SR2MUX_sel)       // SR2 多路选择器
        1'b0:   SR2MUX_out = SR2_out;
        1'b1:   SR2MUX_out = {{12{IR[4]}}, {IR[3:0]}};
    endcase
end

always @(*) begin
    case (ADDR1MUX_sel)     // ADDR1 多路选择器
        1'b0:   ADDR1MUX_out = PC;
        1'b1:   ADDR1MUX_out = SR1_out;
    endcase 
end

always @(*) begin
    case (ADDR2MUX_sel)     // ADDR2 多路选择器
        2'b00:   ADDR2MUX_out = 0;
        2'b01:   ADDR2MUX_out = {{11{IR[5]}}, {IR[4:0]}};
        2'b10:   ADDR2MUX_out = {{8{IR[ 8]}}, {IR[7:0]}};
        2'b11:   ADDR2MUX_out = {{6{IR[10]}}, {IR[9:0]}};
    endcase
end

always @(*) begin
    case (PCMUX_sel)        // PC 多路选择器
        2'b00:   PCMUX_out = PC + 1;
        2'b11:   PCMUX_out = PC + 1;
        2'b01:   PCMUX_out = ADDR1MUX_out + ADDR2MUX_out;
        2'b10:   PCMUX_out = DataPath;    
    endcase
end

always @(*) begin
    case (MARMUX_sel)       // MAR 多路选择器
        1'b0:   MARMUX_out = {{9{IR[ 7]}}, {IR[6:0]}};
        1'b1:   MARMUX_out = ADDR1MUX_out + ADDR2MUX_out;
    endcase
end

always @(*) begin           // MDR 多路选择器
    case (MDRMUX_sel)
        1'b0:   MDRMUX_out = MEM_out;
        1'b1:   MDRMUX_out = DataPath;
    endcase
end

ALU alu(
    .src0(SR1_out),
    .src1(SR2MUX_out),
    .sel(ALU_sel),
    .res(ALU_out)
);

RegFile regfile(
    .clk(clk),
    .rst(rst),
    .ra0(sw[2:0]),
    .ra1(SR1_sel),
    .ra2(SR2_sel),
    .wa(DR_sel),
    .we(LD_REG),
    .din(DataPath),
    .dout0(echo_out),
    .dout1(SR1_out),
    .dout2(SR2_out)
);

dist_mem_gen_0 memory(
    .a(MAR[9:0]),
    .d(MDR),
    .dpra(addr_temp[9:0]),   /* 串口读出操作的地址 */
    .clk(clk),
    .we(MEM_sel),
    .spo(MEM_out),
    .dpo(res)           /* 串口读出操作的输出 */
);

initial begin           // 用于仿真的 initial
    LD_MDR = 0;
    LD_MAR = 0;
    LD_IR = 0;
    LD_CC = 0;
    LD_REG = 0;
    LD_PC = 0;
    MEM_sel = 0;
    GateMDR = 0; 
    GateALU = 0;
    GatePC = 0;
    GateMARMUX = 0;
    jump_flag = 0;
    start_flag = 0;
    write_flag = 0;
    cnt = 0;
end
endmodule
```

#### Receive 模块

```v
module Receive(
    input                   [ 0 : 0]        clk,
    input                   [ 0 : 0]        rst,

    input                   [ 0 : 0]        din,

    output      reg         [ 0 : 0]        din_vld,
    output      reg         [ 7 : 0]        din_data
);

// Counter and parameters
localparam FullT        = 10416;
localparam HalfT        = 5208;
localparam TOTAL_BITS   = 8;
reg [13 : 0] div_cnt;       // 分频计数器，范围 0 ~ 10416
reg [ 3 : 0] din_cnt;       // 位计数器，范围 0 ~ 8

// Main FSM
localparam WAIT     = 0;
localparam START    = 1;	// 接收起始状态，该状态只持续 HalfT
localparam RECEIVE  = 2;	// 接收数据状态，每位数据持续 FullT
reg [1:0] current_state, next_state;
reg next_div_cnt_flag;		// div_cnt 归零标记
always @(posedge clk) begin
    if (rst)
        current_state <= WAIT;
    else
        current_state <= next_state;
end

always @(*) begin
    next_state = current_state;
    next_div_cnt_flag = 0;
    case (current_state)
        // TODO
        WAIT:    begin
            if (din == 0) begin			// 起始位为 0
                next_state = START;
            end
        end
        START:   begin
            if (div_cnt == HalfT) begin		// START 态持续 HalfT，结束后进入 RECEIVE 态，并将 div_cnt 归零
                next_state = RECEIVE;
                next_div_cnt_flag = 1;
            end
        end
        RECEIVE: begin
            if (din_cnt == TOTAL_BITS && div_cnt == FullT) begin	// 所有数据位接收结束后回至 WAIT 态
                next_state = WAIT;
                next_div_cnt_flag = 1;
            end
            else if (div_cnt == FullT) begin	// 每位接收持续 FullT，每位结束后需将 div_cnt 归零
                next_div_cnt_flag = 1;
            end
        end
    endcase
end

// Counter
always @(posedge clk) begin
    if (rst)
        div_cnt <= 0;
    else if (current_state == START) begin
        // TODO
        if (next_div_cnt_flag)
            div_cnt <= 0;
        else
            div_cnt <= div_cnt + 1;
    end
    else if (current_state == RECEIVE) begin
        // TODO
        if (next_div_cnt_flag)
            div_cnt <= 0;
        else
            div_cnt <= div_cnt + 1;
    end
    else 
        div_cnt <= 0;
end

always @(posedge clk) begin
    if (rst)
        din_cnt <= 0;
    else if (current_state == RECEIVE) begin
        // TODO
        if (din_cnt == TOTAL_BITS && div_cnt == FullT) begin
            din_cnt <= 0;
        end
        else if (div_cnt == FullT) 		// 每位接收持续 FullT，每位结束后 din_cnt 增加 1
            din_cnt <= din_cnt + 1;
        else
            din_cnt <= din_cnt;
    end
    else
        din_cnt <= 0;
end


// Output signals
reg [ 0 : 0] accept_din;    // 位采样信号
always @(*) begin
    accept_din = 1'B0;
    // TODO
    if (div_cnt == FullT && din_cnt < TOTAL_BITS)		// 该位的中间时刻为最佳采样时刻
        accept_din = 1'B1;
end

always @(*) begin
    din_vld = 1'B0;
    // TODO
    if (div_cnt == FullT && din_cnt == TOTAL_BITS)		// 完成本轮接收
        din_vld = 1'B1;
end

always @(posedge clk) begin
    if (rst)
        din_data <= 8'B0;
    else if (current_state == WAIT)
        din_data <= 8'B0;
    else if (current_state == START)
        din_data <= 8'B0;
    else if (accept_din)
        din_data <= din_data | (din << din_cnt);
    else
        din_data <= din_data;
end
endmodule
```

#### RegFile 模块

```v
module RegFile (
    input                     clk,          // 时钟信号
    input                     rst,          // 系统复位信号
    input         [2:0]       ra0,          // 读端口 0 地址
    input         [2:0]       ra1,          // 读端口 1 地址
    input         [2:0]       ra2,          // 读端口 2 地址
    input         [2:0]       wa,           // 写端口地址
    input                     we,           // 写使能信号
    input         [15:0]      din,          // 写数据
    output  reg   [15:0]      dout0,        // 读端口 0 数据输出
    output  reg   [15:0]      dout1,        // 读端口 1 数据输出
    output  reg   [15:0]      dout2         // 读端口 2 数据输出
);

reg [15:0] reg_file [7:0];                  // 8 个 16 位寄存器

// 写端口
always @(posedge clk) begin
    if (rst) begin
        reg_file[0] <= 0;
        reg_file[1] <= 0;
        reg_file[2] <= 0;
        reg_file[3] <= 0;
        reg_file[4] <= 0;
        reg_file[5] <= 0;
        reg_file[6] <= 0;
        reg_file[7] <= 0;
    end
    else begin
        if (we) begin
            reg_file[wa] <= din;
        end
        else begin
            reg_file[wa] <= reg_file[wa];
        end
    end
end

// 读端口
always @(*) begin
    dout0 = reg_file[ra0];
    dout1 = reg_file[ra1];
    dout2 = reg_file[ra2];
end

endmodule
```

#### Segment 模块

```v
module Segment(
    input                       clk,                // 时钟信号
    input                       rst,                // 复位信号
    input       [31:0]          output_data,        // 待显示数据
    input       [ 7:0]          output_valid,       // 掩码
    output reg  [ 3:0]          seg_data,
    output reg  [ 2:0]          seg_an
);

reg [31:0]  counter;
reg [2:0]   seg_id;

always @(posedge clk) begin
    if (rst) begin
        counter <= 0;
    end
    else if (counter >= 250000) begin
        counter <= 0;
    end
    else begin
        counter <= counter + 1;
    end
end

always @(posedge clk) begin
    if (rst) begin
        seg_id <= 0;
    end
    else if (counter == 1) begin
        if (seg_id >= 8) begin
            seg_id <= 0;
        end
        else begin
            seg_id <= seg_id + 1;
        end
    end
    else begin
        seg_id <= seg_id;
    end
end

always @(*) begin
    seg_data = 0;
    if (output_valid[seg_id] == 1) begin
        seg_an = seg_id;
    end
    else begin
        seg_an = 0;
    end

    case (seg_an)
        0: seg_data = output_data[3:0];
        1: seg_data = output_data[7:4];
        2: seg_data = output_data[11:8];
        3: seg_data = output_data[15:12];
        4: seg_data = output_data[19:16];
        5: seg_data = output_data[23:20];
        6: seg_data = output_data[27:24];
        7: seg_data = output_data[31:28];
        default: seg_data = 0;
    endcase
end
endmodule
```

#### Send 模块

```v
module Send(
    input                   [ 0 : 0]        clk, 
    input                   [ 0 : 0]        rst,

    output      reg         [ 0 : 0]        dout,

    input                   [ 0 : 0]        dout_vld,
    input                   [ 7 : 0]        dout_data
);

// Counter and parameters
localparam FullT        = 10416;
localparam TOTAL_BITS   = 9;
reg [13 : 0] div_cnt;           // 分频计数器，范围 0 ~ 10416
reg [ 4 : 0] dout_cnt;          // 位计数器，范围 0 ~ 9

// Main FSM
localparam WAIT     = 0;
localparam SEND     = 1;
reg current_state, next_state;
always @(posedge clk) begin
    if (rst)
        current_state <= WAIT;
    else
        current_state <= next_state;
end

always @(*) begin
    next_state = current_state;
    case (current_state)
        // TODO
        WAIT:   begin
            if (dout_vld == 1) begin	// vld 为 1 时开始发送
                next_state = SEND;
            end
        end
        SEND:   begin
            if (dout_cnt == TOTAL_BITS && div_cnt == FullT) begin	// 发送完所有 bits 的该周期结束时，重回 WAIT 态
                next_state = WAIT;
            end
        end
    endcase

end

// Counter
always @(posedge clk) begin
    if (rst)
        div_cnt <= 13'H0;
    else if (current_state == SEND) begin
        // TODO
        if (div_cnt > FullT)	// 计数器，每 FullT 循环一次
            div_cnt <= 13'H0;
        else
            div_cnt <= div_cnt + 13'H1;
    end
    else
        div_cnt <= 13'H0;
end

always @(posedge clk) begin
    if (rst)
        dout_cnt <= 4'H0;
    else if (current_state == SEND) begin
        // TODO
        if (dout_cnt > TOTAL_BITS)
            dout_cnt <= 10'H0;
        else begin
            if (div_cnt == FullT)	// div_cnt 每循环一次，dout_cnt 增加 1，进入下一位发送
                dout_cnt <= dout_cnt + 10'H1;	
            else
                dout_cnt <= dout_cnt;
        end
    end
    else
        dout_cnt <= 4'H0;
end

reg [7 : 0] temp_data;      // 用于保留待发送数据，这样就不怕 dout_data 的变化了
always @(posedge clk) begin
    if (rst)
        temp_data <= 8'H0;
    else if (current_state == WAIT && dout_vld)
        temp_data <= dout_data;
end

always @(posedge clk) begin
    if (rst)
        dout <= 1'B1;
    else begin
        // TODO
        if (next_state == WAIT) begin
            dout <= 1'B1;
        end
        else begin
            case (dout_cnt)
                0:  dout <= 1'B0;		// 标记起始位
                9:  dout <= 1'B1;		// 标记停止位
                default:    dout <= temp_data[dout_cnt-1];	//数据位，从低位至高位依次发送
            endcase
        end
    end
end
endmodule
```

#### Top 模块

```v
module Top(
    input                       clk,            // 时钟
    input                       btn,            // 按钮
    input       [ 7:0]          sw,             // 开关
    input                       uart_din,       /* 串口输入 */
    output      [ 7:0]          led,            // 灯
    output      [ 3:0]          seg_data,       // 数码管
    output      [ 2:0]          seg_an,
    output                      uart_dout       /* 串口输出 */
);

parameter IDLE      = 4'b0000;
parameter S1        = 4'b0001;
parameter S2        = 4'b0010;
parameter S3        = 4'b0011;
parameter S4        = 4'b0100;
parameter DONE      = 4'b0101;

wire [ 7:0] din_data;           /* 串口接收数据帧 */
wire        din_vld;            /* 串口接收数据帧有效信号*/

wire [15:0] output_uart;        /* 数码管低四位 */
wire [15:0] output_data;        // 数码管高四位

wire        posedge_btn;  
wire        rst;

reg         vld;
reg  [ 1:0] mode;
reg  [ 7:0] mode_temp;
reg  [15:0] addr;
reg  [ 3:0] transform; 

reg  [ 3:0] current_state;
reg  [ 3:0] next_state;

reg sig_r1, sig_r2;
always @(posedge clk) begin
    if (rst) begin
        sig_r1 <= 0;
        sig_r2 <= 0;
    end
    else begin
        sig_r1 <= btn;
        sig_r2 <= sig_r1;
    end
end
assign posedge_btn = (sig_r1 && ~sig_r2) ? 1 : 0;       // btn 取上升沿
assign led = {8{btn}};
assign rst = sw[7];

Controller controller(
    .clk            (clk),
    .rst            (rst),
    .btn            (posedge_btn),
    .sw             (sw[3:0]),
    .vld            (vld),
    .mode           (mode),
    .addr           (addr),                    
    .echo           (output_data), 
    .res            (output_uart)           
);

Segment segment(
    .clk            (clk),
    .rst            (rst),
    .output_data    ({output_data, output_uart}),
    .output_valid   (8'b11111111),
    .seg_data       (seg_data),
    .seg_an         (seg_an)
);

Receive receive (
    .clk        (clk),
    .rst        (rst),
    .din        (uart_din),
    .din_vld    (din_vld),
    .din_data   (din_data)
);

Send send(
    .clk        (clk),
    .rst        (rst),
    .dout       (uart_dout),
    .dout_vld   (vld),
    .dout_data  (mode_temp)
);

always @(posedge clk) begin     /* addr 始终为最后四位串口输入的字符 */
    if (rst)
        addr <= 16'b0;
    else if (din_vld)
        addr <= {addr[11:0], transform};
end

always @(*) begin
    transform = transform;
    if (din_vld) begin
        case (din_data)             /* 串口接收数据帧由 ASCII 转为十六进制数 */
            8'h30:      transform = 8'h0;
            8'h31:      transform = 8'h1;
            8'h32:      transform = 8'h2;
            8'h33:      transform = 8'h3;
            8'h34:      transform = 8'h4;
            8'h35:      transform = 8'h5;
            8'h36:      transform = 8'h6;
            8'h37:      transform = 8'h7;
            8'h38:      transform = 8'h8;
            8'h39:      transform = 8'h9;

            8'h41:      transform = 8'hA;
            8'h42:      transform = 8'hB;
            8'h43:      transform = 8'hC;
            8'h44:      transform = 8'hD;
            8'h45:      transform = 8'hE;
            8'h46:      transform = 8'hF;

            8'h61:      transform = 8'hA;
            8'h62:      transform = 8'hB;
            8'h63:      transform = 8'hC;
            8'h64:      transform = 8'hD;
            8'h65:      transform = 8'hE;
            8'h66:      transform = 8'hF;

            default:    transform = 8'h0;
        endcase
    end
end

// Part 1: 使用同步时序进行状态更新，即更新 current_state 的内容
always @(posedge clk) begin
    if (rst)  
        current_state <= IDLE;
    else 
        current_state <= next_state;
end

// Part 2: 使用组合逻辑判断状态跳转逻辑，即根据 current_state 与其他信号确定 next_state
always @(*) begin
    next_state = current_state;
    vld = 0;
    case (current_state)
        IDLE: begin
            if (din_vld) begin
                case (din_data)
                    8'h6A: begin    /* 'j' 跳转 */
                        mode = 0;
                        mode_temp = 8'h6A;
                        next_state = S1;
                    end
                    8'h72: begin    /* 'r' 读出 */
                        mode = 1;
                        mode_temp = 8'h72;
                        next_state = S1;
                    end
                    8'h73: begin    /* 's' 运行 */
                        mode = 2;
                        mode_temp = 8'h73;
                        next_state = S1;
                    end
                    8'h77: begin    /* 'w' 写入 */
                        mode = 3;
                        mode_temp = 8'h77;
                        next_state = S1;
                    end
                    default: next_state = IDLE;
                endcase
            end
        end
        S1: begin
            if (din_vld) begin
                case (din_data)
                    8'h6A: begin    /* 'j' 跳转 */
                        mode = 0;
                        mode_temp = 8'h6A;
                        next_state = S1;
                    end
                    8'h72: begin    /* 'r' 读出 */
                        mode = 1;
                        mode_temp = 8'h72;
                        next_state = S1;
                    end
                    8'h73: begin    /* 's' 运行 */
                        mode = 2;
                        mode_temp = 8'h73;
                        next_state = S1;
                    end
                    8'h77: begin    /* 'w' 写入 */
                        mode = 3;
                        mode_temp = 8'h77;
                        next_state = S1;
                    end
                    default: next_state = S2;
                endcase
            end
        end
        S2: begin
            if (din_vld) begin
                case (din_data)
                    8'h6A: begin    /* 'j' 跳转 */
                        mode = 0;
                        mode_temp = 8'h6A;
                        next_state = S1;
                    end
                    8'h72: begin    /* 'r' 读出 */
                        mode = 1;
                        mode_temp = 8'h72;
                        next_state = S1;
                    end
                    8'h73: begin    /* 's' 运行 */
                        mode = 2;
                        mode_temp = 8'h73;
                        next_state = S1;
                    end
                    8'h77: begin    /* 'w' 写入 */
                        mode = 3;
                        mode_temp = 8'h77;
                        next_state = S1;
                    end
                    default: next_state = S3;
                endcase
            end
        end
        S3: begin
            if (din_vld) begin
                case (din_data)
                    8'h6A: begin    /* 'j' 跳转 */
                        mode = 0;
                        mode_temp = 8'h6A;
                        next_state = S1;
                    end
                    8'h72: begin    /* 'r' 读出 */
                        mode = 1;
                        mode_temp = 8'h72;
                        next_state = S1;
                    end
                    8'h73: begin    /* 's' 运行 */
                        mode = 2;
                        mode_temp = 8'h73;
                        next_state = S1;
                    end
                    8'h77: begin    /* 'w' 写入 */
                        mode = 3;
                        mode_temp = 8'h77;
                        next_state = S1;
                    end
                    default: next_state = S4;
                endcase
            end
        end
        S4: begin
            if (din_vld) begin
                case (din_data)
                    8'h6A: begin    /* 'j' 跳转 */
                        mode = 0;
                        mode_temp = 8'h6A;
                        next_state = S1;
                    end
                    8'h72: begin    /* 'r' 读出 */
                        mode = 1;
                        mode_temp = 8'h72;
                        next_state = S1;
                    end
                    8'h73: begin    /* 's' 运行 */
                        mode = 2;
                        mode_temp = 8'h73;
                        next_state = S1;
                    end
                    8'h77: begin    /* 'w' 写入 */
                        mode = 3;
                        mode_temp = 8'h77;
                        next_state = S1;
                    end
                    default: next_state = DONE;
                endcase
            end
        end
        DONE: begin
            vld = 1;
            next_state = IDLE;
        end
    endcase
end
endmodule
```

### 4. 测试结果

#### 仿真测试

Coefficient 文件

```
memory_initialization_radix = 16;
memory_initialization_vector =
903F, 1200, 5467, 4080, 927F, 14BC, 03FD, 0000,
1901, 2BFE, 1B63, 3A00, 0000, 7B8B, 0000, 0000;
```

相应的机器语言程序及注释

```
1001000000111111	; R0 <- ~R0
0001001000000000	; R1 <- R0 + R0
0101010001100111	; R2 <- R1 & #3
0100000010000000	; R7 <- PC, PC <- R2
1001001001111111	; R0 <- ~R0
0001010010111100	; R2 <- R2 + #-4
0000001111111101	; >0 ? goto: PC + #-3
0000000000000000
0001100100000001	; R4 <- R4 + #1
0010101111111110	; R5 <- M[PC + #-2]
0001101101100011	; R5 <- R5 + #3
0011101000000000	; M[PC] <- R5
0000000000000000
0111101110001011	; R5 <- M[R6 + #11]
0000000000000000	
0000000000000000
```

TestBench 文件

```v
module LC3_tb();
reg             clk;
reg             btn;
reg     [7:0]   sw;
reg             uart_din;
wire    [7:0]   led;      
wire    [3:0]   seg_data;
wire    [2:0]   seg_an;
wire            uart_dout;

initial begin
    clk = 0;
    uart_din = 1;
    sw = 8'b10000000;
    btn = 0;
    #10 sw = 8'b00000000;

    // r0002
    #200000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    repeat (3) begin
        #200000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 1;
        #104000 uart_din = 1;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 1;
    end
    #200000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;

    // j000E
    #200000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    repeat (3) begin
        #200000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 1;
        #104000 uart_din = 1;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 1;
    end
    #200000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;

    // wF025
    #200000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;

    #200000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;

    #200000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    
    #200000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    
    #200000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;

    // j0000
    #200000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    repeat (4) begin
        #200000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 1;
        #104000 uart_din = 1;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 1;
    end

    #200000;
    repeat (5) begin
        #110 btn = 1;
        #10 btn = 0;
    end

    // s0020
    #200000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    repeat (2) begin
        #200000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 1;
        #104000 uart_din = 1;
        #104000 uart_din = 0;
        #104000 uart_din = 0;
        #104000 uart_din = 1;
    end
    #200000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;

    #200000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
    #104000 uart_din = 1;
    #104000 uart_din = 0;
    #104000 uart_din = 0;
    #104000 uart_din = 1;
end

always #5 clk = ~clk;

Top top(
    .clk(clk),
    .btn(btn),
    .sw(sw),
    .uart_din(uart_din),
    .led(led),
    .seg_data(seg_data),
    .seg_an(seg_an),
    .uart_dout(uart_dout)
);
endmodule
```

简言之，即依次进行下述外设操作及串口操作：

```
sw[3:0] = 0000
rst = 1, rst = 0
read 	x0002
jump 	x000E
write 	xF025
jump	x0000
btn = 1, btn = 0
btn = 1, btn = 0
btn = 1, btn = 0
btn = 1, btn = 0
btn = 1, btn = 0
start 	x0020
```

仿真测试截图  1，主要用于展示 Top 模块对外交互的逻辑正确性

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_sim1.png)

仿真测试截图  2，主要用于展示 Controller 模块指令执行的逻辑正确性，并注意时间轴上单位有所变化

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_sim2.png)

#### 上板测试

执行`rst = 1, rst = 0`之后：

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl1.png)

执行`read 	x0002`之后：

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl2.png)

执行`jump 	x000E`之后：

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl3.png)

执行`write 	xF025`之后：

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl4.png)

执行`jump	x0000`之后：

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl5.png)

执行第一次`btn = 1, btn = 0`之后：

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl6.png)

执行共五次`btn = 1, btn = 0`之后：

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl7.png)

执行`start 	x0020`之后：

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl8.png)

此时地址 x000C 的值为 x1904，且寄存器`R0-R7`的值依次为：

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl9.png)

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl10.png)

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl11.png)

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl12.png)

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl13.png)

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl14.png)

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl15.png)

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver1\figs\LC3_impl16.png)

#### 补充测试

补充测试 1，以下是一段求解最大公因数的汇编程序：

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver2\figs\LC3_test1.png)

其对应的机器语言程序如下，其中修改了`LDI`与`STI`指令的部分，并填入测试样例`A = 0000000011110111 (x00F7 = 13 * 19)`与`B = 0000000010011100 (x009C = 13 * 12)`：

```
0000001000000000
1010000000011110	; 改为 0010000000011110
1010001000011110	; 改为 1010001000011110
0101000000000000
0000001000000010
1001000000111111
0001000000100001
0101001001000001
0000100000000010
1001001001111111
0001001001100001
0001010001000000
0000010000010001
0000100000001000
0101010001000001
0001011010000000
0001011011000010
0000001000000010
0001000000000010
0000111111110111
0001010010000010
0000111111111001
0101010000000000
0001011010000001
0001011010000011
0000100000000010
0001001001000010
0000111111101111
0001010010000010
0000111111111001
1011000000000011	; 改为 0011000000000011
1111000000100101
0000001100000000	; 改为 0000000011110111
0000001100000001	; 改为 0000000010011100
0000001100000010	; 改为 0000000000000000
```

通过下述串口操作的输入，将程序写入内存并予以运行：

```
j0200
w201E
w221E
w5000
w0202
w903F
w1021
w5241
w0802
w927F
w1261
w1440
w0411
w0808
w5441
w1680
w16C2
w0202
w1002
w0FF7
w1482
w0FF9
w5400
w1681
w1683
w0802
w1242
w0FEF
w1482
w0FF9
w3003
wF025
w00F7
w009C
w0000
j0200
r0221
s00FF
```

截图如下所示，与所预期结果`C = 0000000000001101 (x000d = 13)`相符：

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver2\figs\LC3_test2.png)

补充测试 2，以下是一段递归方法求 Save(n)的汇编程序，其中
$$
Save(n)=\begin{cases}
10, &\text{if }n=0\\
Save(n-1)+Earn(n-1)-Spend(n-1), &\text{if }n>0
\end{cases}\\
Earn(n)=\begin{cases}
6, &\text{if }n=0\\
Earn(n-1)*2, &\text{if }n>0
\end{cases}\\
Spend(n)=\begin{cases}
2, &\text{if }n=0\\
2, &\text{if }n>0\text{ and }Spend(n-1)\ge Earn(n-1)\\
Spend(n-1)*4, &\text{if }n>0\text{ and }Spend(n-1)< Earn(n-1)
\end{cases}
$$
![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver2\figs\LC3_test3.png)

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver2\figs\LC3_test4.png)

其对应的机器语言程序如下，其中修改了`LDI`与`STI`指令的部分，并填入测试样例`n = 0000000000001010 (x000A = 10)`：

```
0011000000000000	; 改为 0000001000000000
1010000001001101	; 改为 0010000001001101
0010110001001011
0100100000101100
1011000001001011	; 改为 0011000001001011
1111000000100101
0001110110111111
0111111110000000
0001000000100000
0000010000000100
0001000000111111
0100111111111010
0001000000000000
0000111000000001
0001000000100110
0110111110000000
0001110110100001
1100000111000000
0001110110111111
0111111110000000
0001110110111111
0111001110000000
0001110110111111
0111010110000000
0001000000100000
0000010000001101
0001000000111111
0001001000100000
0100111111101001
0001010000100000
1001010010111111
0001010010100001
0001000001100000
0100111111110000
0001010010000000
0000011000000011
0001000000000000
0001000000000000
0000111000000010
0101000000100000
0001000000100010
0110010110000000
0001110110100001
0110001110000000
0001110110100001
0110111110000000
0001110110100001
1100000111000000
0001110110111111
0111111110000000
0001110110111111
0111001110000000
0001110110111111
0111010110000000
0001000000100000
0000010000001101
0001000000111111
0001001000100000
0100111111010111
0001010000100000
1001010010111111
0001010010100001
0001000001100000
0100111111000110
0001010010000000
0001000001100000
0100111111101101
0001000010000000
0000111000000010
0101000000100000
0001000000101010
0110010110000000
0001110110100001
0110001110000000
0001110110100001
0110111110000000
0001110110100001
1100000111000000
0110000000000000	; 改为 0000001100000000
0011000100000000	; 改为 0000000000001010
0011001000000000	; 改为 0000000000000000
```

通过下述串口操作的输入，将程序写入内存并予以运行：

```
j0200
w204D
w2C4B
w482C
w304B
wF025
w1DBF
w7F80
w1020
w0404
w103F
w4FFA
w1000
w0E01
w1026
w6F80
w1DA1
wC1C0
w1DBF
w7F80
w1DBF
w7380
w1DBF
w7580
w1020
w040D
w103F
w1220
w4FE9
w1420
w94BF
w14A1
w1060
w4FF0
w1480
w0603
w1000
w1000
w0E02
w5020
w1022
w6580
w1DA1
w6380
w1DA1
w6F80
w1DA1
wC1C0
w1DBF
w7F80
w1DBF
w7380
w1DBF
w7580
w1020
w040D
w103F
w1220
w4FD7
w1420
w94BF
w14A1
w1060
w4FC6
w1480
w1060
w4FED
w1080
w0E02
w5020
w102A
w6580
w1DA1
w6380
w1DA1
w6F80
w1DA1
wC1C0
w0300
w000A
w0000
j0200
r024F
s0FFF
```

截图如下所示，与所预期结果`Save(n) = 0000110100101110 (x0d2e = 3374)`相符：

![](D:\2024 秋季学期 学习\13 模拟与数字电路实验\lab8_奚项正_PB23000020_ver2\figs\LC3_test5.png)

### 5. 反思总结

- 本次实验，对于 Verilog 语言有了更深入的了解，同时学会串口通信协议并进行整体协调程序。
- 复习了 ICS 中所学的知识，完成此实验后在心理上认为自己基本掌握了如何造一台计算机，收获颇丰。
- 可以认为这是我目前学过的计科课程中收获最多的之一，学会根据仿真调代码等，每一次做完实验都有一种满满的成就感。
- 最后感谢助教们的耐心讲解与解答，助教们辛苦惹捏～完结撒花！
